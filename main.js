/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LightweightChatGPTPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiKey: "",
  maxTokens: 16,
  temperature: 1,
  chatGPTModel: "gpt-3.5-turbo",
  insertionMode: "end",
  showSidebarIcon: true
};
var LightweightChatGPTPlugin = class extends import_obsidian.Plugin {
  async onload() {
    try {
      await this.loadSettings();
    } catch (error) {
      console.error("Error loading settings:", error);
    }
    this.app.workspace.onLayoutReady(() => {
      if (this.settings.showSidebarIcon) {
        this.addSidebarIcon();
      }
    });
    this.addCommand({
      id: "open-lightweight-window",
      name: "Open Lightweight Window",
      callback: () => {
        try {
          new LightweightChatGPTWindow(this.app, this.settings.apiKey, this.settings.temperature, this.settings.maxTokens, this.settings.chatGPTModel, this.settings.insertionMode).open();
        } catch (error) {
          console.error("Error opening Lightweight ChatGPT Plugin Window:", error);
        }
      }
      // hotkeys: [
      //     {
      //         modifiers: ['CTRL'],
      //         key: 'k',
      //     },
      // ]
    });
    try {
      this.addSettingTab(new LightweightChatGPTSettingTab(this.app, this));
    } catch (error) {
      console.error("Error adding settings tab:", error);
    }
  }
  addSidebarIcon() {
    try {
      this.ribbonIconEl = this.addRibbonIcon("feather", "GPT-LiteInquirer", (evt) => {
        try {
          new LightweightChatGPTWindow(this.app, this.settings.apiKey, this.settings.temperature, this.settings.maxTokens, this.settings.chatGPTModel, this.settings.insertionMode).open();
        } catch (error) {
          console.error("Error opening Lightweight ChatGPT Plugin Window:", error);
        }
      });
    } catch (error) {
      console.error("Error adding sidebar icon:", error);
    }
  }
  removeSidebarIcon() {
    if (this.ribbonIconEl) {
      try {
        this.ribbonIconEl.remove();
      } catch (error) {
        console.error("Error closing sidebar icon:", error);
      }
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var LightweightChatGPTWindow = class extends import_obsidian.Modal {
  constructor(app, apiKey, temperature, maxTokens, chatGPTModel, insertionMode) {
    super(app);
    this.apiKey = apiKey;
    this.temperature = temperature;
    this.maxTokens = maxTokens;
    this.chatGPTModel = chatGPTModel;
    this.insertionMode = insertionMode;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "GPT Lite Inquirer Window" });
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const selectedText = activeView ? activeView.editor.getSelection() : "";
    this.inputTextArea = contentEl.createEl("textarea");
    this.inputTextArea.classList.add("gpt-input-textarea");
    this.inputTextArea.rows = 4;
    this.inputTextArea.placeholder = "Enter your text here ...";
    this.inputTextArea.value = selectedText ? `${selectedText}
====
` : "";
    this.inputTextArea.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey && !event.ctrlKey) {
        event.preventDefault();
        this.insertAtCursor(this.inputTextArea, "\n");
      } else if (event.key === "Enter" && event.ctrlKey) {
        event.preventDefault();
        sendButton.click();
      }
    });
    contentEl.createEl("hr");
    const maxTokensContainer = contentEl.createEl("div");
    maxTokensContainer.className = "max-tokens-container";
    const maxTokensLabelContainer = maxTokensContainer.createEl("div");
    maxTokensLabelContainer.createEl("label", { text: "Max tokens:" });
    const maxTokensDescription = maxTokensLabelContainer.createEl("p", { text: "Max OpenAI ChatGpt Tokens" });
    maxTokensDescription.classList.add("max-tokens-description");
    this.maxTokensInput = maxTokensContainer.createEl("input", { type: "number" });
    this.maxTokensInput.placeholder = "Enter max Tokens number";
    this.maxTokensInput.classList.add("max-tokens-input");
    this.maxTokensInput.min = "1";
    this.maxTokensInput.max = "2048";
    this.maxTokensInput.value = this.maxTokens.toString();
    this.maxTokensInput.addEventListener("input", () => {
      if (parseInt(this.maxTokensInput.value) > parseInt(this.maxTokensInput.max)) {
        this.maxTokensInput.value = this.maxTokensInput.max;
        new import_obsidian.Notice(`Max tokens cannot exceed ${this.maxTokensInput.max}`);
      } else if (!parseInt(this.maxTokensInput.value) && parseInt(this.maxTokensInput.value) < parseInt(this.maxTokensInput.min)) {
        this.maxTokensInput.value = this.maxTokensInput.min;
        new import_obsidian.Notice(`Max tokens cannot be less than ${this.maxTokensInput.min}`);
      }
    });
    const buttonSendContainer = contentEl.createEl("div");
    buttonSendContainer.style.marginTop = "1rem";
    const sendButton = buttonSendContainer.createEl("button", {
      text: "Send"
    }, (el) => {
      el.style.backgroundColor = "green";
      el.style.color = "white";
    });
    const responseDivider = contentEl.createEl("hr");
    responseDivider.style.display = "none";
    this.outputContainer = contentEl.createEl("div");
    this.outputContainer.classList.add("output-container");
    const buttonsContainer = contentEl.createEl("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.marginTop = "1rem";
    const copyToClipboardButton = buttonsContainer.createEl("button", {
      text: "Copy to clipboard"
    }, (el) => {
      el.style.backgroundColor = "green";
      el.style.color = "white";
    });
    copyToClipboardButton.style.marginRight = "1rem";
    copyToClipboardButton.style.display = "none";
    const addToPostButton = buttonsContainer.createEl("button", { text: "Add to current document" });
    addToPostButton.style.marginRight = "1rem";
    addToPostButton.style.display = "none";
    sendButton.addEventListener("click", async () => {
      if (!parseInt(this.maxTokensInput.value)) {
        new import_obsidian.Notice(`Use the default value of ${this.maxTokens.toString()} for max Tokens`);
        this.maxTokensInput.value = this.maxTokens.toString();
      }
      if (!this.inputTextArea.value) {
        new import_obsidian.Notice("Please Enter text");
        return;
      }
      sendButton.textContent = "Sending ...";
      sendButton.textContent = "Waiting for API full response ...";
      copyToClipboardButton.style.display = "none";
      addToPostButton.style.display = "none";
      responseDivider.style.display = "none";
      try {
        this.responseAPIText = await this.sendRequestToChatGPT();
        sendButton.textContent = "Send";
        copyToClipboardButton.style.display = "block";
        addToPostButton.style.display = "block";
        responseDivider.style.display = "block";
      } catch (error) {
        sendButton.textContent = "Send";
      }
    });
    copyToClipboardButton.addEventListener("click", () => {
      this.copyToClipboard(this.responseAPIText);
    });
    addToPostButton.addEventListener("click", () => {
      this.appendToCurrentNote(this.inputTextArea.value, this.responseAPIText, this.insertionMode);
    });
  }
  async sendRequestToChatGPT() {
    if (!this.apiKey) {
      new import_obsidian.Notice("Please enter your API key in the plugin settings.");
      return;
    }
    this.outputContainer.empty();
    new import_obsidian.Notice("Sending...");
    const apiUrl = "https://api.openai.com";
    const apiUrlPatch = "/v1/chat/completions";
    const maxTokens = parseInt(this.maxTokensInput.value);
    try {
      const response = await (0, import_obsidian.request)({
        url: apiUrl + apiUrlPatch,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model: this.chatGPTModel,
          max_tokens: maxTokens,
          temperature: this.temperature,
          messages: [
            { role: "user", content: this.inputTextArea.value }
          ]
        })
      });
      const result = JSON.parse(response);
      if (result.choices && result.choices.length > 0) {
        const gptResponse = result.choices[0].message.content;
        this.outputContainer.empty();
        this.outputContainer.createEl("p", { text: gptResponse });
        return gptResponse;
      } else if (result.error) {
        throw new Error(JSON.stringify(result.error));
      } else {
        throw new Error("Unexpected API response format");
      }
    } catch (error) {
      console.error("Error during API request:", error);
      new import_obsidian.Notice(
        "Error during API request: " + error.message
      );
    }
  }
  insertAtCursor(textArea, text) {
    const startPos = textArea.selectionStart;
    const endPos = textArea.selectionEnd;
    textArea.value = textArea.value.substring(0, startPos) + text + textArea.value.substring(endPos, textArea.value.length);
    textArea.selectionStart = startPos + text.length;
    textArea.selectionEnd = startPos + text.length;
  }
  async appendToCurrentNote(sentText, receivedText, insertionMode) {
    const receivedAPIText = receivedText || "";
    if (receivedAPIText.length <= 0) {
      new import_obsidian.Notice("No text to add");
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    const activeLeaf = activeView == null ? void 0 : activeView.leaf;
    if (activeView && activeLeaf && activeLeaf.view instanceof import_obsidian.MarkdownView) {
      const editor = activeLeaf.view.editor;
      const formattedText = `
---

${receivedAPIText}

---
`;
      if (insertionMode === "end") {
        const lastLine = editor.lastLine();
        editor.replaceRange(formattedText, { line: lastLine + 1, ch: 0 });
      } else if (insertionMode === "current") {
        const cursorPosition = editor.getCursor();
        const currentLine = cursorPosition.line;
        editor.replaceRange(formattedText, { line: currentLine + 1, ch: 0 });
      }
    } else {
      new import_obsidian.Notice("Cannot append content to the current view. Please open a markdown note.");
    }
  }
  async copyToClipboard(receivedText) {
    const receivedAPIText = receivedText || "";
    if (receivedAPIText.length > 0) {
      navigator.clipboard.writeText(receivedAPIText).then(() => {
        new import_obsidian.Notice("Copied to clipboard!");
      }).catch((error) => {
        console.error("Error copying to clipboard:", error);
        new import_obsidian.Notice("Error copying to clipboard");
      });
    } else {
      new import_obsidian.Notice("No text to copy");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var LightweightChatGPTSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings Lightweight ChatGPT Window" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Enter your OpenAI API key").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Max Tokens").setDesc("Enter the maximum number of tokens for the API response (integer, min: 1, max: 2048)").addText((text) => text.setPlaceholder("Enter max tokens").setValue(this.plugin.settings.maxTokens.toString()).onChange(async (value) => {
      let parsedValue = parseInt(value);
      if (parsedValue < 1) {
        parsedValue = 1;
      } else if (parsedValue > 2048) {
        parsedValue = 2048;
      }
      this.plugin.settings.maxTokens = parsedValue;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Temperature").setDesc("Enter the temperature value between 0 and 2 (inclusive) for the API response").addText((text) => text.setPlaceholder("Enter temperature").setValue(this.plugin.settings.temperature.toString()).onChange(async (value) => {
      let parsedValue = parseFloat(value);
      if (parsedValue < 0) {
        parsedValue = 0;
      } else if (parsedValue > 2) {
        parsedValue = 2;
      }
      this.plugin.settings.temperature = parsedValue;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("OpenAI Model").setDesc("Select the OpenAI model to use").addDropdown((dropDown) => dropDown.addOption("gpt-3.5-turbo", "gpt-3.5-turbo").setValue(this.plugin.settings.chatGPTModel).onChange(async (value) => {
      this.plugin.settings.chatGPTModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Insertion Mode").setDesc("Choose how to insert text").addDropdown((dropdown) => dropdown.addOption("end", "Insert at end of document").addOption("current", "Insert at current position").setValue(this.plugin.settings.insertionMode).onChange(async (value) => {
      this.plugin.settings.insertionMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Sidebar Icon").setDesc("Toggle to show or hide the sidebar icon").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSidebarIcon).onChange(async (value) => {
      this.plugin.settings.showSidebarIcon = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.addSidebarIcon();
      } else {
        this.plugin.removeSidebarIcon();
      }
    }));
    const politeMessage = containerEl.createEl("p", {
      cls: "polite-message"
    });
    politeMessage.textContent = "If you enjoy this plugin or would like to show your support, please consider giving it a free star on GitHub~ Your appreciation means a lot to me!";
    const githubLink = containerEl.createEl("div", {
      cls: "github-link-container"
    });
    const githubAnchor = githubLink.createEl("a", {
      cls: "github-link"
    });
    githubAnchor.href = "https://github.com/ittuann/obsidian-gpt-liteinquirer-plugin";
    githubAnchor.target = "_blank";
    githubAnchor.rel = "noopener";
    githubAnchor.createEl("span", {
      text: "View on GitHub"
    });
    const style = document.createElement("style");
    style.innerHTML = `
			.polite-message {
				margin-bottom: 1rem;
				font-style: italic;
			}
			.github-link-container {
				margin-top: 2rem;
				text-align: center;
			}
			.github-link {
				color: #0366d6;
				text-decoration: none;
				border: 1px solid #0366d6;
				border-radius: 4px;
				padding: 0.5rem 1rem;
				font-weight: bold;
				transition: all 0.3s;
			}
			.github-link:hover {
				background-color: #0366d6;
				color: white;
				text-decoration: none;
			}
		`;
    containerEl.appendChild(style);
  }
};
